global contain
global mov_handler_OMI_
global _start

_start:
    mov  eax, tp
    push eax
    call mov_handler_OMI_
    pop  eax
    
    mov  ecx, enter_character
    mov  edx, 1
    mov  ebx, 1
    mov  eax, 4
    int  0x80

    mov  eax, DWORD[output_buffer_cnt]
    xor  ecx, ecx
_print_loop:   
    push eax
    mov  ebx, output_buffer
    add  ebx, ecx
    xor  edx, edx
    mov  dl, BYTE[ebx]
    mov  eax, string
    
    push ecx
    
    push eax
    push edx
    call hex2str_8bit
    pop  edx
    pop  eax
    
    mov  ecx, string
    mov  edx, 2
    mov  ebx, 1
    mov  eax, 4
    int  0x80
    
    pop  ecx
    
    pop  eax
    add  ecx, 1
    cmp  ecx, eax
    jne  _print_loop
    
    mov  eax, 1
    int  0x80
    
extract_imm32_from_memory: ;void extract_imm32_from_memory(char* tp_str, char* imm32_11_characters)
	push ebp
	mov  ebp, esp
	mov  eax, DWORD[ebp+0x08] ; eax contains the tp_str
	mov  ebx, DWORD[ebp+0x0c] ; ebx contains the imm32_buffer
_extract_imm32_from_memory_X:
	xor  ecx, ecx
    mov  cl, BYTE[eax]
    add  eax, 1
    cmp  cl, 0x00
    je   extract_imm32_from_memory_done
    cmp  cl, '0'
    jne  _extract_imm32_from_memory_X
	mov  cl, BYTE[eax]
	add  eax, 1
    cmp  cl, 'x'
    jne  _extract_imm32_from_memory_X
    mov  edx, 10
    sub  eax, 2 ; now eax points to the start of the '0x'
_extract_imm32_from_memory_Y:
    mov  cl, BYTE[eax]
    mov  BYTE[ebx], cl
    add  eax, 1
    add  ebx, 1
    sub  edx, 1
    cmp  edx, 0
    je   extract_imm32_from_memory_last_character
    jmp  _extract_imm32_from_memory_Y
extract_imm32_from_memory_last_character:
    mov  BYTE[ebx], 0x00
extract_imm32_from_memory_done:
	pop  ebx
	mov  esp, ebp
	pop  ebp
	ret
	
hex2str_8bit: ;void hex2str_8bit(UINT_8 num, char* string)
	push ebp
	mov  ebp, esp
	xor  eax, eax
	mov  al,  BYTE[ebp+0x08] ; eax contains the hex number
	mov  ebx, DWORD[ebp+0x0c] ; ebx contains the address of the string
	mov  ecx, 0
	mov  esi, lookup_hex_table
	push ebx
_hex2str_8bit_loop:
	cmp  ecx, 2
	je   _hex2str_8bit_done
	xor  edx, edx
	mov  ebx, 0x10
	div  ebx
	add  ecx, 1
	
	; now edx contains a number between 0 and 15 
	; that should be found in lookup_table
	
	add  edx, esi
	
	; now edx points to the rigt byte
	
	pop  ebx
	push ebx
	mov  edi, 2
	sub  edi, ecx
	add  ebx, edi
	push ecx
	xor  ecx, ecx
	mov  cl, BYTE[edx]
	mov  BYTE[ebx], cl
	pop  ecx
	jmp  _hex2str_8bit_loop
	
_hex2str_8bit_done:
	pop  ebx
	mov  esp, ebp
	pop  ebp
	ret
	
str2hex: ;void str2hex(char* string, UINT_32* num)
	push ebp
	mov  ebp, esp
	mov  eax, DWORD[ebp+0x08]
	mov  ebx, DWORD[ebp+0x0c]
	mov  DWORD[ebx], 0x00000000
	
; first of all check if it is a real hex-containing string
	xor  ecx, ecx
	mov  cl, BYTE[eax]
	cmp  cl, '0'
	jne  _str2hex_error
	add  eax, 1
	mov  cl, BYTE[eax]
	cmp  cl, 'x'
	jne  _str2hex_error
	
; now we know that eax starts with a in (0xaAbBcCdD) string
	xor  edx, edx
	mov  ebx, 8
_str2hex_start_iteration:
	mov  cl, BYTE[eax]
	mov  esi, lookup_hex_table
_str2hex_X:
	mov  ch,  BYTE[esi]
	cmp  ch, cl
	je   _str2hex_found_entry_in_lookup_table
	add  esi, 1
	jmp  _str2hex_X
_str2hex_found_entry_in_lookup_table:
	; now esi contains the right address of the byte from the lookup_hex_table
	; and ch containg the right byte pointerd by esi, but we need a number between 0 and 15
	sub esi, lookup_hex_table
	; now esi contains one of the digts of the right number that should be assigned to the num
	
	; it would be ~> esi * (16 ^ ebx)
	push ebx
	push eax
	mov  eax, 1
_str2hex_Y:
	cmp  ebx, 0
	je   _str2hex_continue
	imul eax, 16
	sub  ebx, 1
	jmp  _str2hex_Y
_str2hex_continue:
	; now eax = (16 ^ ebx)
	imul esi, eax
	pop  eax
	pop  ebx
	mov  edx, DWORD[ebp+0xc]
	add  DWORD[edx], esi
	xor  esi, esi
	cmp  ebx, 0
	je   _str2hex_end
	sub  ebx, 1
	add  eax, 1
	jmp  _str2hex_start_iteration
_str2hex_error:
	mov  ebx, DWORD[ebp+0xc]
	mov  DWORD[ebx], 0
_str2hex_end:
	mov  esp, ebp
	pop  ebp
	ret

str2hex_16bit: ;void str2hex_16bit(char* string, UINT_16* num)
	push ebp
	mov  ebp, esp
	mov  eax, DWORD[ebp+0x08]
	mov  ebx, DWORD[ebp+0x0c]
	mov  WORD[ebx], 0x000000
	
; first of all check if it is a real hex-containing string
	xor  ecx, ecx
	mov  cl, BYTE[eax]
	cmp  cl, '0'
	jne  _str2hex_16bit_error
	add  eax, 1
	mov  cl, BYTE[eax]
	cmp  cl, 'x'
	jne  _str2hex_16bit_error
	
; now we know that eax starts with a in (0xaA) string
	xor  edx, edx
	mov  ebx, 4
_str2hex_16bit_start_iteration:
	mov  cl, BYTE[eax]
	mov  esi, lookup_hex_table
_str2hex_16bit_X:
	mov  ch,  BYTE[esi]
	cmp  ch, cl
	je   _str2hex_16bit_found_entry_in_lookup_table
	add  esi, 1
	jmp  _str2hex_16bit_X
_str2hex_16bit_found_entry_in_lookup_table:
	; now esi contains the right address of the byte from the lookup_hex_table
	; and ch containg the right byte pointerd by esi, but we need a number between 0 and 15
	sub esi, lookup_hex_table
	; now esi contains one of the digits of the right number that should be assigned to the num
	
	; it would be ~> esi * (16 ^ ebx)
	push ebx
	push eax
	mov  eax, 1
_str2hex_16bit_Y:
	cmp  ebx, 0
	je   _str2hex_16bit_continue
	imul eax, 16
	sub  ebx, 1
	jmp  _str2hex_16bit_Y
_str2hex_16bit_continue:
	; now eax = (16 ^ ebx)
	imul esi, eax
	pop  eax
	pop  ebx
	mov  edx, DWORD[ebp+0xc]
	xor  ecx, ecx
	mov  ecx, esi
	add  WORD[edx], cx
	xor  esi, esi
	cmp  ebx, 0
	je   _str2hex_16bit_end
	sub  ebx, 1
	add  eax, 1
	xor  ecx, ecx
	jmp  _str2hex_16bit_start_iteration
_str2hex_16bit_error:
	mov  ebx, DWORD[ebp+0xc]
	mov  WORD[ebx], 0
_str2hex_16bit_end:
	mov  esp, ebp
	pop  ebp
	ret
	
str2hex_8bit: ;void str2hex(char* string, UINT_8* num)
	push ebp
	mov  ebp, esp
	mov  eax, DWORD[ebp+0x08]
	mov  ebx, DWORD[ebp+0x0c]
	mov  BYTE[ebx], 0x00
	
; first of all check if it is a real hex-containing string
	xor  ecx, ecx
	mov  cl, BYTE[eax]
	cmp  cl, '0'
	jne  _str2hex_8bit_error
	add  eax, 1
	mov  cl, BYTE[eax]
	cmp  cl, 'x'
	jne  _str2hex_8bit_error
	
; now we know that eax starts with a in (0xaA) string
	xor  edx, edx
	mov  ebx, 2
_str2hex_8bit_start_iteration:
	mov  cl, BYTE[eax]
	mov  esi, lookup_hex_table
_str2hex_8bit_X:
	mov  ch,  BYTE[esi]
	cmp  ch, cl
	je   _str2hex_8bit_found_entry_in_lookup_table
	add  esi, 1
	jmp  _str2hex_8bit_X
_str2hex_8bit_found_entry_in_lookup_table:
	; now esi contains the right address of the byte from the lookup_hex_table
	; and ch containg the right byte pointerd by esi, but we need a number between 0 and 15
	sub esi, lookup_hex_table
	; now esi contains one of the digits of the right number that should be assigned to the num
	
	; it would be ~> esi * (16 ^ ebx)
	push ebx
	push eax
	mov  eax, 1
_str2hex_8bit_Y:
	cmp  ebx, 0
	je   _str2hex_8bit_continue
	imul eax, 16
	sub  ebx, 1
	jmp  _str2hex_8bit_Y
_str2hex_8bit_continue:
	; now eax = (16 ^ ebx)
	imul esi, eax
	pop  eax
	pop  ebx
	mov  edx, DWORD[ebp+0xc]
	xor  ecx, ecx
	mov  ecx, esi
	add  BYTE[edx], cl
	xor  esi, esi
	cmp  ebx, 0
	je   _str2hex_8bit_end
	sub  ebx, 1
	add  eax, 1
	xor  ecx, ecx
	jmp  _str2hex_8bit_start_iteration
_str2hex_8bit_error:
	mov  ebx, DWORD[ebp+0xc]
	mov  BYTE[ebx], 0
_str2hex_8bit_end:
	mov  esp, ebp
	pop  ebp
	ret
	
contain: ;void _contain(char* string, char* substring, UINT_32* status) ~>status = 1 (if yes), ~>status = 0 (if not)
    push ebp
    mov  ebp, esp
    mov  eax, DWORD[ebp+0x08]
    mov  ebx, DWORD[ebp+0x0c]
    xor  esi, esi ;strlen(string)
    xor  edi, edi ;strlen(substring)
    xor  ecx, ecx
    push eax
_len_determination_mother:
    mov cl, BYTE[eax]
    cmp cl, 0
    je  _X
    add eax, 1
    add esi, 1
    jmp _len_determination_mother
_X:
    pop  eax
    push ebx
    xor  ecx, ecx
_len_determination_baby:
    mov cl, BYTE[ebx]
    cmp cl, 0
    je  _Y
    add ebx, 1
    add edi, 1
    jmp _len_determination_baby
_Y:
    pop  ebx
    xor  ecx, ecx

; if substring > string ~> result is for sure 0
    mov  ecx, esi
    sub  ecx, edi
    cmp  ecx, 0
    jl  _sure_false_when_string_lengths_violate
    
; if we made it until here, this is the time for real comparing bytes
    xor  ecx, ecx
    xor  edx, edx ;a counter
    push eax
    push ebx
_perform_bytewise:
    mov  cl, BYTE[eax]
    mov  ch, BYTE[ebx]
    cmp  ch, 0
    je   _sure_true
    cmp  ch, cl
    jne  _reset_substring
    add  ebx, 1
    add  eax, 1
    jmp  _perform_bytewise
_reset_substring:
    pop  ebx
    pop  eax
    add  eax, 1
    push eax
    push ebx
    ; check for the very last possible comparison
    mov  ecx, DWORD[ebp+8]
    add  ecx, esi
    add  ecx, 1
    sub  ecx, eax
    cmp  ecx, edi
    je   _sure_false
    xor  ecx, ecx
    jmp  _perform_bytewise
_sure_false:
    pop  ebx
    pop  eax
_sure_false_when_string_lengths_violate:
    mov ecx, DWORD[ebp+16]
    mov  DWORD[ecx], 0x00000000
    jmp __end
_sure_true:
    pop  ebx
    pop  eax
    mov ecx, DWORD[ebp+16]
    mov  DWORD[ecx], 0x00000001
__end:
    mov  esp, ebp
    pop  ebp
    ret
    
    
    
mov_handler_OMI_: ;void mov_handler(TP* tp)
	push ebp
	mov  ebp, esp
	
	; first off, clear all reporting bytes
	mov  BYTE[opcode], 0
	mov  BYTE[modrm] , 0
	mov  BYTE[prefix], 0
	mov  BYTE[sib],    0
	
	mov  eax, displ32
	mov  BYTE[eax], 0
	add  eax, 1
	mov  BYTE[eax], 0
	add  eax, 1
	mov  BYTE[eax], 0
	add  eax, 1
	mov  BYTE[eax], 0
	
	; then MOV MEM, IMM
	mov  BYTE[opcode], 0xC6
	mov  BYTE[modrm],  0x00 ; 00,000,000
	
	mov  eax, DWORD[ebp+0x8]

	add  eax, 128 ; now eax points to tp_str2
	mov  ebx, ISBA_RMIK_AREA ; now ebx points to EAX
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _found_EAX_as_second
	add  ebx, 4 ; now ebx points to ECX
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _found_ECX_as_second
	add  ebx, 4 ; now ebx points to EDX
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _found_EDX_as_second
	add  ebx, 4 ; now ebx points to EBX
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _found_EBX_as_second
	add  ebx, 4 ; now ebx points to ESI
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _found_ESI_as_second
	add  ebx, 4 ; now ebx points to EDI
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _found_EDI_as_second
	add  ebx, 4 ; now ebx points to EBP
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _found_EBP_as_second
	add  ebx, 4 ; now ebx points to ESP
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _found_ESP_as_second
	
_found_EAX_as_second:
    push eax
    mov  ecx, second_message
	mov  edx, 24
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	mov  ecx, ISBA_RMIK_AREA
	add  ecx, 0x00
	mov  edx, 4
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	pop  eax
	push eax
    add  BYTE[modrm],  0x00
    mov  ebx, ISBA_RMIK_AREA
    add  ebx, 85 ; now ebx point to string 'DWORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _dword_found
	add  ebx, 6 ; now ebx point to string 'WORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _word_found
	add  ebx, 5 ; now ebx point to string 'BYTE',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _byte_found

_found_EBX_as_second:
	push eax
    mov  ecx, second_message
	mov  edx, 24
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	mov  ecx, ISBA_RMIK_AREA
	add  ecx, 0x0C
	mov  edx, 4
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	pop  eax
	push eax
    add  BYTE[modrm],  0x03
    mov  ebx, ISBA_RMIK_AREA
    add  ebx, 85 ; now ebx point to string 'DWORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _dword_found
	add  ebx, 6 ; now ebx point to string 'WORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _word_found
	add  ebx, 5 ; now ebx point to string 'BYTE',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _byte_found
	
_found_ECX_as_second:
    push eax
    mov  ecx, second_message
	mov  edx, 24
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	mov  ecx, ISBA_RMIK_AREA
	add  ecx, 0x04
	mov  edx, 4
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	pop  eax
	push eax
    add  BYTE[modrm],  0x01
    mov  ebx, ISBA_RMIK_AREA
    add  ebx, 85 ; now ebx point to string 'DWORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _dword_found
	add  ebx, 6 ; now ebx point to string 'WORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _word_found
	add  ebx, 5 ; now ebx point to string 'BYTE',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _byte_found

_found_EDX_as_second:
    push eax
    mov  ecx, second_message
	mov  edx, 24
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	mov  ecx, ISBA_RMIK_AREA
	add  ecx, 0x08
	mov  edx, 4
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	pop  eax
	push eax
    add  BYTE[modrm],  0x02
    mov  ebx, ISBA_RMIK_AREA
    add  ebx, 85 ; now ebx point to string 'DWORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _dword_found
	add  ebx, 6 ; now ebx point to string 'WORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _word_found
	add  ebx, 5 ; now ebx point to string 'BYTE',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _byte_found
	
_found_ESI_as_second:
    push eax
    mov  ecx, second_message
	mov  edx, 24
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	mov  ecx, ISBA_RMIK_AREA
	add  ecx, 0x10
	mov  edx, 4
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	pop  eax
	push eax
    add  BYTE[modrm],  0x06
    mov  ebx, ISBA_RMIK_AREA
    add  ebx, 85 ; now ebx point to string 'DWORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _dword_found
	add  ebx, 6 ; now ebx point to string 'WORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _word_found
	add  ebx, 5 ; now ebx point to string 'BYTE',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _byte_found
	
_found_EDI_as_second:
    push eax
    mov  ecx, second_message
	mov  edx, 24
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	mov  ecx, ISBA_RMIK_AREA
	add  ecx, 0x14
	mov  edx, 4
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	pop  eax
	push eax
    add  BYTE[modrm],  0x07
    mov  ebx, ISBA_RMIK_AREA
    add  ebx, 85 ; now ebx point to string 'DWORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _dword_found
	add  ebx, 6 ; now ebx point to string 'WORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _word_found
	add  ebx, 5 ; now ebx point to string 'BYTE',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _byte_found
	
_found_EBP_as_second:
    push eax
    mov  ecx, second_message
	mov  edx, 24
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	mov  ecx, ISBA_RMIK_AREA
	add  ecx, 0x18
	mov  edx, 4
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	pop  eax
	push eax
	or   BYTE[modrm],  0x80
    add  BYTE[modrm],  0x05
    mov  DWORD[displ32_boolean], 1
    mov  ebx, ISBA_RMIK_AREA
    add  ebx, 85 ; now ebx point to string 'DWORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _dword_found
	add  ebx, 6 ; now ebx point to string 'WORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _word_found
	add  ebx, 5 ; now ebx point to string 'BYTE',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _byte_found
	
_found_ESP_as_second:
    push eax
    mov  ecx, second_message
	mov  edx, 24
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	mov  ecx, ISBA_RMIK_AREA
	add  ecx, 0x1C
	mov  edx, 4
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	pop  eax
	push eax
    add  BYTE[modrm],  0x04
	add  BYTE[sib],    0x24
    mov  DWORD[sib_boolean], 1
    mov  ebx, ISBA_RMIK_AREA
    add  ebx, 85 ; now ebx point to string 'DWORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _dword_found
	add  ebx, 6 ; now ebx point to string 'WORD',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _word_found
	add  ebx, 5 ; now ebx point to string 'BYTE',0
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	je   _byte_found
_dword_found:
    add  BYTE[opcode], 0x01
    jmp _further_to_third_string
_word_found:
    add  BYTE[opcode], 0x01
    add  BYTE[prefix], 0x66
    jmp _further_to_third_string
_byte_found:
    jmp _further_to_third_string

_further_to_third_string:
	mov  ecx, enter_character
	mov  edx, 1
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	
	pop  eax
	add  eax, 128 ; now eax points to tp_str3
	
	; determine which immediate should be used
	push eax
	xor  edi, edi
	xor  ecx, ecx
_which_immediate_loop:
	mov  cl, BYTE[eax]
	add  edi, 1
	add  eax, 1
	cmp  cl, 0x00
	jne  _which_immediate_loop
	pop  eax
	cmp  edi, 5
	je   _imm8_found
	cmp  edi, 7
	je   _imm16_found
	cmp  edi, 11
	je   _imm32_found
	jmp  _error_immediate
_imm8_found:
    mov  DWORD[which_immediate], 1
    mov  ecx, imm8
    push ecx
    push eax
    call str2hex_8bit
    pop  eax
    pop  ecx
    jmp  _parse_1_end
_imm16_found:
    mov  DWORD[which_immediate], 2
    mov  ecx, imm16
    push ecx
    push eax
    call str2hex_16bit
    pop  eax
    pop  ecx
    jmp  _parse_1_end
_imm32_found:
    mov  DWORD[which_immediate], 3
    mov  ecx, imm32
    push ecx
    push eax
    call str2hex
    pop  eax
    pop  ecx
    jmp  _parse_1_end
_error_immediate:
	mov  DWORD[which_immediate], 0
	jmp  _completely_done
	
_parse_1_end:
    ; is there an immediate in memory ?
    mov  eax, DWORD[ebp+0x8]
	add  eax, 128 ; now eax points to tp_str2
    mov  ebx, ISBA_RMIK_AREA
    add  ebx, 83 ; now ebx points to +
	mov  DWORD[ISBA_BOOLEAN], 0x00000000
	mov  edx, ISBA_BOOLEAN
	push edx
	push ebx
	push eax
	call contain
	pop  eax
	pop  ebx
	pop  edx
	mov  edx, DWORD[ISBA_BOOLEAN]
	cmp  edx, 1
	jne  _no_imm
_there_is_hexadecimal:
    or   BYTE[modrm],  0x80
    mov  ebx, DWORD[ebp+0x8]
    add  ebx, 128
    mov  ecx, __imm32
    push ecx
    push ebx
    call extract_imm32_from_memory
    pop  ebx
    pop  ecx
    mov  DWORD[displ32_boolean], 1
    mov  ebx, RESERVED_DWORD
    push ebx
    push ecx
    call str2hex
    pop  ecx
    pop  ebx
    mov  eax, displ32
    xor  ecx, ecx
    mov  cl, BYTE[ebx]
	mov  BYTE[eax], cl
	add  eax, 1
	add  ebx, 1
	mov  cl, BYTE[ebx]
	mov  BYTE[eax], cl
	add  eax, 1
	add  ebx, 1
	mov  cl, BYTE[ebx]
	mov  BYTE[eax], cl
	add  eax, 1
	add  ebx, 1
	mov  cl, BYTE[ebx]
	mov  BYTE[eax], cl
    
_no_imm:
    ; update output_buffer and output_buffer_cnt
    mov  eax, output_buffer
    mov  ebx, DWORD[output_buffer_cnt]
    
    xor  ecx, ecx
    mov  cl, BYTE[prefix]
    cmp  cl, 0x00
    jne  _update_prefix
_above:
    mov  cl, BYTE[opcode]
    jmp  _update_opcode
_above_2:
    mov  cl, BYTE[modrm]
    jmp  _update_modrm
_above_3:
    mov  cl, BYTE[sib]
    jmp  _update_sib
_above_4:
    mov  cl, BYTE[displ32]
    jmp  _update_displ32
_above_5:
    cmp  DWORD[which_immediate], 1
    je   _encode_imm8
    cmp  DWORD[which_immediate], 2
    je   _encode_imm16
    cmp  DWORD[which_immediate], 3
    je   _encode_imm32
    jmp  _completely_done
_update_prefix:
    add  eax, ebx
    mov  BYTE[eax], cl
    xor  ecx, ecx
    add  DWORD[output_buffer_cnt], 1
    mov  ebx, DWORD[output_buffer_cnt]
    jmp  _above
_update_opcode:
    mov  eax, output_buffer
    add  eax, ebx
    mov  BYTE[eax], cl
    xor  ecx, ecx
    add  DWORD[output_buffer_cnt], 1
    mov  ebx, DWORD[output_buffer_cnt]
    jmp  _above_2
_update_modrm:
    mov  eax, output_buffer
    add  eax, ebx
    mov  BYTE[eax], cl
    xor  ecx, ecx
    add  DWORD[output_buffer_cnt], 1
    mov  ebx, DWORD[output_buffer_cnt]
    jmp  _above_3
_update_sib:
    mov  eax, DWORD[sib_boolean]  
    cmp  eax, 0
    je   _above_4
    mov  eax, output_buffer
    add  eax, ebx
    mov  BYTE[eax], cl
    xor  ecx, ecx
    add  DWORD[output_buffer_cnt], 1
    mov  ebx, DWORD[output_buffer_cnt]
    mov  DWORD[sib_boolean], 0
    jmp  _above_4
_update_displ32:
    mov  eax, DWORD[displ32_boolean]  
    cmp  eax, 0
    je   _above_5
    mov  esi, output_buffer
    add  esi, ebx
    mov  BYTE[esi], cl
    add  esi, 1
    mov  eax, displ32
    add  eax, 1
    mov  cl, BYTE[eax]
    mov  BYTE[esi], cl
    add  esi, 1
    add  eax, 1
    mov  cl, BYTE[eax]
    mov  BYTE[esi], cl
    add  esi, 1
    add  eax, 1
    mov  cl, BYTE[eax]
    mov  BYTE[esi], cl
    add  DWORD[output_buffer_cnt], 4
    mov  ebx, DWORD[output_buffer_cnt]
    jmp  _above_5
_encode_imm8:
    mov  eax, output_buffer
    mov  ebx, DWORD[output_buffer_cnt]
    add  eax, ebx
    xor  ecx, ecx
    mov  edx, imm8
    mov  cl, BYTE[edx]
    mov  BYTE[eax], cl
    add  eax, 1
    add  edx, 1
    mov  cl, BYTE[edx]
    mov  BYTE[eax], cl
    add  DWORD[output_buffer_cnt], 1
    jmp  _completely_done
_encode_imm16:
    mov  eax, output_buffer
    mov  ebx, DWORD[output_buffer_cnt]
    add  eax, ebx
    xor  ecx, ecx
    mov  edx, imm16
    mov  cl, BYTE[edx]
    mov  BYTE[eax], cl
    add  eax, 1
    add  edx, 1
    mov  cl, BYTE[edx]
    mov  BYTE[eax], cl
    add  eax, 1
    add  edx, 1
    mov  cl, BYTE[edx]
    mov  BYTE[eax], cl
    add  DWORD[output_buffer_cnt], 2
    jmp  _completely_done
_encode_imm32:
    mov  eax, output_buffer
    mov  ebx, DWORD[output_buffer_cnt]
    add  eax, ebx
    xor  ecx, ecx
    mov  edx, imm32
    mov  cl, BYTE[edx]
    mov  BYTE[eax], cl
    add  eax, 1
    add  edx, 1
    mov  cl, BYTE[edx]
    mov  BYTE[eax], cl
    add  eax, 1
    add  edx, 1
    mov  cl, BYTE[edx]
    mov  BYTE[eax], cl
    add  eax, 1
    add  edx, 1
    mov  cl, BYTE[edx]
    mov  BYTE[eax], cl
    add  eax, 1
    add  edx, 1
    mov  cl, BYTE[edx]
    mov  BYTE[eax], cl
    add  DWORD[output_buffer_cnt], 4
    jmp  _completely_done
    
_completely_done:    
	mov  esp, ebp
	pop  ebp
	ret
	
section .data
	ISBA_RMIK_AREA:	 
	                     db 'eax',   0
						 db 'ecx',   0
						 db 'edx',   0
						 db 'ebx',   0
						 db 'esi',   0
						 db 'edi',   0
						 db 'ebp',   0
						 db 'esp',   0
						 db 'ax',    0
						 db 'cx',    0
						 db 'dx',    0
						 db 'bx',    0
						 db 'si',    0
						 db 'di',    0
						 db 'bp',    0
						 db 'sp',    0
						 db 'ah',    0
						 db 'al',    0
						 db 'ch',    0
						 db 'cl',    0
						 db 'dh',    0
						 db 'dl',    0
						 db 'bh',    0
						 db 'bl',    0
						 db '0x',    0
						 db '+',     0
						 ; offset 85
						 db 'DWORD', 0
						 ; offset 91
						 db 'WORD',  0
						 ; offset 96
						 db 'BYTE',  0
						 ; offset 101
						 
	ISBA_GLOB_MN_ADDR:   db 'mov',0
						 db 'add',0
						 db 'sub',0
	tp:				  
	                     db 'mov',0, '...........................................................................................................................', 0
						 db 'DWORD[esp+0x10203040]',0, '.........................................................................................................', 0
						 db '0xFC125612',0, '....................................................................................................................', 0
						 db 'omi',0
						 
	output_buffer:       db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	output_buffer_cnt:   dd 0x00000000
	
	opcode:              db 0
	modrm:               db 0
	prefix:              db 0
	sib:                 db 0
	displ32:             db 0,0,0,0
	__imm32:             db 0,0,0,0,0,0,0,0,0,0,0
	sib_boolean:         dd 0
	displ32_boolean:     dd 0
	
	imm32:               dd 0x00000000
	imm16:               dw 0x0000
	imm8:                db 0x00
	
	; which-immediate (0 | >3 = error, 1 = imm32, 2 = imm16, 3 = imm8)
	which_immediate:     dd 0
	
	ISBA_BOOLEAN:		 dd 0xFFFFFFFF
	second_message:	     db 'the second register is: ',0
	
	string:			     db '0x00',0
	lookup_hex_table:    db '0123456789ABCDEF', 0
	
	enter_character:	 db 0xa
	RESERVED_DWORD:      dd 0x00000000
