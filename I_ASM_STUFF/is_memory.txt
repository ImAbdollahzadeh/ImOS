section .text
global _start
global is_memory

_start:
	mov  eax, string
	mov  ebx, return
	push ebx
	push eax
	call is_memory
	pop  eax
	pop  ebx
	
; debugging ------------------------------------------------
    mov  eax, DWORD[return]
    cmp  eax, 0
    je   _FALSE_PRINT
    cmp  eax, 1
    je   _TRUE_PRINT
_FALSE_PRINT:
	mov  ecx, FALSE
	mov  edx, 5
	mov  ebx, 1
	mov  eax, 4
	int  0x80 
	jmp  _print_done
	
_TRUE_PRINT:
	mov  ecx, _TRUE
	mov  edx, 5
	mov  ebx, 1
	mov  eax, 4
	int  0x80
	
_print_done:
	mov  eax, 1
	int  0x80
; ----------------------------------------------------------- 
   
is_memory: ;void is_memory(char* string, uint32* return)
	push ebp
	mov  ebp, esp
	xor  ecx, ecx
	xor  edx, edx
	xor  ebx, ebx
	mov  eax, DWORD[ebp+0x8] ; eax contains the address of the string
    push eax
_is_memory_start_length:
	mov  bl, BYTE[eax]
	cmp  bl, 0x00
	je   _is_memory_length_done
	add  ecx, 1
	add  eax, 1
	jmp  _is_memory_start_length
_is_memory_length_done:
    pop  eax
    xor  ebx, ebx
    
    ; the last characters must be ']'
_is_memory_sanity_check:
    push eax
    add  eax, ecx
    sub  eax, 1
    mov  bl, BYTE[eax]
    pop  eax
	cmp  bl, ']'
	jne  _is_memory_sure_false
	
	; they must begin with memory keywords
	; a.k.a. BYTE, WORD, DWORD, QWORD, or XXMWORD
	
	push eax
	; 1. check for BYTE
_is_memory_byte_keyword_check:	
    mov  bl, BYTE[eax]
	cmp  bl, 'B'
	jne  _is_memory_word_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'Y'
	jne  _is_memory_word_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'T'
	jne  _is_memory_word_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'E'
	jne  _is_memory_word_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, '['
	jne  _is_memory_word_keyword_check
	pop  eax
	jmp  _is_memory_sure_true
	; 2. check for WORD
_is_memory_word_keyword_check:
    pop  eax
    push eax
    mov  bl, BYTE[eax]
	cmp  bl, 'W'
	jne  _is_memory_dword_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'O'
	jne  _is_memory_dword_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'R'
	jne  _is_memory_dword_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'D'
	jne  _is_memory_dword_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, '['
	jne  _is_memory_dword_keyword_check
	pop  eax
	jmp  _is_memory_sure_true
	; 3. check for DWORD
_is_memory_dword_keyword_check:
    pop  eax
    push eax
    mov  bl, BYTE[eax]
    cmp  bl, 'D'
	jne  _is_memory_qword_keyword_check
    add  eax, 1
    mov  bl, BYTE[eax]
	cmp  bl, 'W'
	jne  _is_memory_qword_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'O'
	jne  _is_memory_qword_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'R'
	jne  _is_memory_qword_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'D'
	jne  _is_memory_qword_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, '['
	jne  _is_memory_qword_keyword_check
	pop  eax
	jmp  _is_memory_sure_true
	; 4. check for QWORD
_is_memory_qword_keyword_check:
    pop  eax
    push eax
    mov  bl, BYTE[eax]
    cmp  bl, 'Q'
	jne  _is_memory_xmmword_keyword_check
    add  eax, 1
    mov  bl, BYTE[eax]
	cmp  bl, 'W'
	jne  _is_memory_xmmword_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'O'
	jne  _is_memory_xmmword_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'R'
	jne  _is_memory_xmmword_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'D'
	jne  _is_memory_xmmword_keyword_check
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, '['
	jne  _is_memory_xmmword_keyword_check
	pop  eax
	jmp  _is_memory_sure_true
	; 5. check for XMMWORD
_is_memory_xmmword_keyword_check:
    pop  eax
    mov  bl, BYTE[eax]
    cmp  bl, 'X'
	jne  _is_memory_sure_false
	add  eax, 1
    mov  bl, BYTE[eax]
	cmp  bl, 'M'
	jne  _is_memory_sure_false
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'M'
	jne  _is_memory_sure_false
    add  eax, 1
    mov  bl, BYTE[eax]
	cmp  bl, 'W'
	jne  _is_memory_sure_false
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'O'
	jne  _is_memory_sure_false
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'R'
	jne  _is_memory_sure_false
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, 'D'
	jne  _is_memory_sure_false
	add  eax, 1
	mov  bl, BYTE[eax]
	cmp  bl, '['
	jne  _is_memory_sure_false

_is_memory_sure_true:
    mov  ebx, DWORD[ebp+0xc] ; ebx contains the address of the return
	mov  DWORD[ebx], 1
	jmp  _is_memory_end
_is_memory_sure_false:
    mov  ebx, DWORD[ebp+0xc] ; ebx contains the address of the return
	mov  DWORD[ebx], 0
_is_memory_end:
	mov  esp, ebp
	pop  ebp
	ret
section .data
	string:			                db 'XMMWORD[eax]', 0
	return:                         dd 0xFFFFFFFF
	_TRUE:                          db '_true', 0
	FALSE:                          db 'false', 0
	
	bytes ~>
	{ 
		0x55, 0x89, 0xE5, 0x8B, 0x45, 0x08, 0x50, 0x8A, 0x18, 0x80, 0xFB, 0x00, 0x74, 0x08, 0x83, 0xC1, 
		0x01, 0x83, 0xC0, 0x01, 0xEB, 0xF1, 0x58, 0x31, 0xDB, 0x50, 0x01, 0xC8, 0x83, 0xE8, 0x01, 0x8A, 
		0x18, 0x58, 0x80, 0xFB, 0x5D, 0x0F, 0x85, 0x45, 0x01, 0x00, 0x00, 0x50, 0x8A, 0x18, 0x80, 0xFB, 
		0x42, 0x75, 0x2E, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x59, 0x75, 0x24, 0x83, 0xC0, 0x01, 
		0x8A, 0x18, 0x80, 0xFB, 0x54, 0x75, 0x1A, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x45, 0x75, 
		0x10, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x5B, 0x75, 0x06, 0x58, 0xE9, 0x04, 0x01, 0x00, 
		0x00, 0x58, 0x50, 0x8A, 0x18, 0x80, 0xFB, 0x57, 0x75, 0x2E, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 
		0xFB, 0x4F, 0x75, 0x24, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x52, 0x75, 0x1A, 0x83, 0xC0, 
		0x01, 0x8A, 0x18, 0x80, 0xFB, 0x44, 0x75, 0x10, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x5B, 
		0x75, 0x06, 0x58, 0xE9, 0xCD, 0x00, 0x00, 0x00, 0x58, 0x50, 0x8A, 0x18, 0x80, 0xFB, 0x44, 0x75, 
		0x38, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x57, 0x75, 0x2E, 0x83, 0xC0, 0x01, 0x8A, 0x18, 
		0x80, 0xFB, 0x4F, 0x75, 0x24, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x52, 0x75, 0x1A, 0x83, 
		0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x44, 0x75, 0x10, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 
		0x5B, 0x75, 0x06, 0x58, 0xE9, 0x8C, 0x00, 0x00, 0x00, 0x58, 0x50, 0x8A, 0x18, 0x80, 0xFB, 0x51, 
		0x75, 0x35, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x57, 0x75, 0x2B, 0x83, 0xC0, 0x01, 0x8A, 
		0x18, 0x80, 0xFB, 0x4F, 0x75, 0x21, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x52, 0x75, 0x17, 
		0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x44, 0x75, 0x0D, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 
		0xFB, 0x5B, 0x75, 0x03, 0x58, 0xEB, 0x4E, 0x58, 0x8A, 0x18, 0x80, 0xFB, 0x58, 0x75, 0x51, 0x83, 
		0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x4D, 0x75, 0x47, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 
		0x4D, 0x75, 0x3D, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x57, 0x75, 0x33, 0x83, 0xC0, 0x01, 
		0x8A, 0x18, 0x80, 0xFB, 0x4F, 0x75, 0x29, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x52, 0x75, 
		0x1F, 0x83, 0xC0, 0x01, 0x8A, 0x18, 0x80, 0xFB, 0x44, 0x75, 0x15, 0x83, 0xC0, 0x01, 0x8A, 0x18, 
		0x80, 0xFB, 0x5B, 0x75, 0x0B, 0x8B, 0x5D, 0x0C, 0xC7, 0x03, 0x01, 0x00, 0x00, 0x00, 0xEB, 0x09, 
		0x8B, 0x5D, 0x0C, 0xC7, 0x03, 0x00, 0x00, 0x00, 0x00, 0x89, 0xEC, 0x5D, 0xC3 
	}
